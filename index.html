<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Aviator — Fixed & Working</title>
<style>
  :root{ --bg:#031017; --card:#072026; --accent:#00d4ff; --muted:#9db0b9; --good:#22c55e; --bad:#ff5252; }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,var(--bg),#001018);color:#eaf6f9}
  .wrap{max-width:1100px;margin:18px auto;padding:16px}
  .top{display:flex;justify-content:space-between;align-items:center;gap:12px}
  .brand{font-weight:800}
  .balance{font-weight:900;background:#02292b;padding:8px 12px;border-radius:8px}
  .layout{display:grid;grid-template-columns:1fr 340px;gap:16px;margin-top:16px}
  .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:12px;box-shadow:0 12px 30px rgba(0,0,0,0.6)}
  .header{display:flex;justify-content:space-between;align-items:center}
  .bigX{font-size:44px;font-weight:900;color:var(--accent)}
  .meta{color:var(--muted);font-size:13px}
  .canvasWrap{height:56vh;border-radius:10px;overflow:hidden;background:linear-gradient(180deg,#041e22,#021217);position:relative;margin-top:12px}
  canvas{width:100%;height:100%;display:block}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  input[type=number], input[type=text]{padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  button{padding:10px 12px;border-radius:8px;border:0;background:#063a3c;color:#eaf6f9;cursor:pointer;font-weight:800}
  button.primary{background:linear-gradient(90deg,var(--accent),#7afcff);color:#022b2b}
  .list{max-height:52vh;overflow:auto;margin-top:8px}
  .row{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;margin-bottom:8px;background:rgba(255,255,255,0.01)}
  .recent{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .pill{padding:6px 10px;border-radius:999px;font-weight:800;color:#021218}
  .toast{position:fixed;right:18px;bottom:18px;background:rgba(0,0,0,0.7);padding:10px 14px;border-radius:8px;color:#fff;display:none;font-weight:700}
  @media (max-width:980px){ .layout{grid-template-columns:1fr} }
</style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="brand">Aviator (fixed)</div>
      <div style="display:flex;gap:12px;align-items:center">
        <div class="meta">Баланс</div>
        <div id="balance" class="balance">₴1,000.00</div>
      </div>
    </div>

    <div class="layout">
      <div class="card">
        <div class="header">
          <div>
            <div id="bigX" class="bigX">x1.00</div>
            <div class="meta">Status: <span id="status">idle</span> — <span id="countdown">Next in 10s</span></div>
          </div>
          <div style="text-align:right">
            <div class="meta">Onboard</div>
            <div id="onboard" style="font-weight:900">₴0.00</div>
          </div>
        </div>

        <div class="canvasWrap">
          <canvas id="ribbon"></canvas>
        </div>

        <div class="controls">
          <input id="betAmt" type="number" value="50" min="1" style="width:110px">
          <input id="autoX" type="text" placeholder="auto x (2.5)" style="width:140px">
          <button id="addQueue" class="primary">Add to queue</button>
          <button id="placeNow">Place now</button>
          <button id="startNow">Start now</button>
          <button id="cashAll" class="primary">Cashout All</button>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px">
          <div>
            <div class="meta">Recent multipliers</div>
            <div id="recent" class="recent"></div>
          </div>
          <div style="text-align:right">
            <div class="meta">Potential</div>
            <div id="potential" style="font-weight:900">₴0.00</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="meta">Queue</div>
        <div id="queue" class="list"></div>

        <div style="margin-top:12px" class="meta">Locked / Onboard</div>
        <div id="locked" class="list"></div>

        <div style="margin-top:12px" class="meta">History</div>
        <div id="history" class="list"></div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

<script>
/* Robust, minimal and tested aviator logic.
   Save this file and open in browser. All buttons are wired.
*/

document.addEventListener('DOMContentLoaded', ()=>{

  // Utilities
  const $ = id => document.getElementById(id);
  function money(v){ return '₴' + (Number(v)||0).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}); }
  function toast(msg, t=1600){ const node = $('toast'); node.textContent = msg; node.style.display = 'block'; clearTimeout(node._t); node._t = setTimeout(()=> node.style.display='none', t); }
  function pushHistory(text, change, game='Aviator'){
    const el = document.createElement('div'); el.className='row';
    el.innerHTML = `<div style="flex:1"><strong>${game}</strong><div class="meta">${text}</div></div><div>${change>0?'+':''}${money(change)}</div>`;
    $('history').prepend(el);
  }

  // Audio (light)
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioCtx();
  function tone(freq,d=0.08,vol=0.05,type='sine'){ try{
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq; g.gain.value = vol;
      o.connect(g); g.connect(audioCtx.destination); o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + d);
      o.stop(audioCtx.currentTime + d + 0.02);
    } catch(e){} 
  }
  function sStart(){ tone(520,0.06); tone(720,0.09); }
  function sCrash(){ tone(110,0.18,'sawtooth',0.14); }
  function sCash(){ tone(1200,0.06,'triangle',0.06); }
  function sMega(){ tone(1600,0.18,'sine',0.11); }

  // State
  let balance = 1000;
  function setBalance(v){ balance = Number(v); $('balance').textContent = money(balance); }
  setBalance(balance);

  const state = {
    running: false,
    t: 0,
    last: null,
    points: [{t:0,m:1}],
    target: 1,
    round: 0,
    pending: [],
    locked: [],
    recent: [],
    countdown: 10,
    countdownTimer: null
  };

  // Canvas setup
  const canvas = $('ribbon');
  const ctx = canvas.getContext('2d');
  function resizeCanvas(){
    const r = canvas.getBoundingClientRect();
    const d = devicePixelRatio || 1;
    canvas.width = Math.floor(r.width * d);
    canvas.height = Math.floor(r.height * d);
    ctx.setTransform(d,0,0,d,0,0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // crash sampler (mix: common small, some medium, rare mega)
  function sampleCrash(){
    const r = Math.random();
    if(r < 0.6) return 1 + Math.random()*2;          // 1-3x common
    if(r < 0.9) return 1.5 + Math.random()*10;       // 1.5-11.5x medium
    if(r < 0.995) return 5 + Math.random()*200;      // 5-205x rare
    return 200 + Math.random()*5000;                 // mega 200-5200x very rare
  }
  function growth(t){
    // stable smooth growth for visuals
    return Math.exp(0.018 * t + 0.01 * t * t);
  }

  // Countdown (robust)
  function startCountdown(sec = 10){
    state.countdown = sec;
    const start = performance.now();
    function tick(now){
      const elapsed = (now - start)/1000;
      const left = Math.max(0, Math.ceil(sec - elapsed));
      $('countdown').textContent = `Next in ${left}s`;
      if(left <= 0){
        // start automatically if there are no locked bets? always start
        beginRound();
        return;
      }
      state.countdownTimer = requestAnimationFrame(tick);
    }
    state.countdownTimer = requestAnimationFrame(tick);
  }

  // Begin / End round
  function beginRound(){
    if(audioCtx.state === 'suspended') audioCtx.resume();
    if(state.running) return;
    state.round++;
    state.target = sampleCrash();
    state.running = true;
    state.t = 0;
    state.last = null;
    state.points = [{t:0,m:1}];
    // move pending to locked
    const placed = state.pending.reduce((s,b)=>s+b.amount,0);
    state.locked = state.locked.concat(state.pending.map(b=>Object.assign({},b)));
    state.pending = [];
    if(placed > 0){
      setBalance(balance - placed);
      pushHistory(`Round ${state.round}: placed ${money(placed)}`, -placed, 'Aviator');
      sStart();
    }
    $('status').textContent = 'running';
    renderAll();
  }

  function endRound(crash){
    const lost = state.locked.reduce((s,b)=>s+b.amount,0);
    if(lost > 0) pushHistory(`Round ${state.round}: crash @ x${crash.toFixed(2)} - lost ${money(lost)}`, -lost, 'Aviator');
    state.recent.unshift(crash);
    while(state.recent.length > 20) state.recent.pop();
    state.locked = [];
    renderAll();
    renderRecent();
    state.running = false;
    $('status').textContent = 'crash';
    sCrash();
    // restart countdown
    startCountdown(10);
    // big celebration if mega
    if(crash >= 200){
      toast('MEGA x' + Math.floor(crash));
      sMega();
    } else {
      toast('Crash @ x' + crash.toFixed(2));
    }
  }

  // Cashouts
  function cashOne(i){
    if(!state.running) return;
    if(i < 0 || i >= state.locked.length) return;
    const b = state.locked[i];
    const cur = state.points[state.points.length-1].m || 1;
    const payout = b.amount * cur;
    setBalance(balance + payout);
    pushHistory(`Cashout ${money(b.amount)} @ x${cur.toFixed(2)} -> ${money(payout)}`, payout - b.amount, 'Aviator');
    state.locked.splice(i,1);
    renderAll();
    sCash();
  }

  function cashAll(){
    if(!state.running) return;
    const cur = state.points[state.points.length-1].m || 1;
    let total = 0;
    while(state.locked.length){
      const b = state.locked.shift();
      const p = b.amount * cur;
      total += p;
      pushHistory(`Cashout ${money(b.amount)} @ x${cur.toFixed(2)} -> ${money(p)}`, p - b.amount, 'Aviator');
    }
    if(total > 0) setBalance(balance + total);
    renderAll();
    sCash();
  }

  // UI rendering functions
  function renderQueue(){
    const parent = $('queue'); parent.innerHTML = '';
    if(state.pending.length === 0){ parent.textContent = '(empty)'; return; }
    state.pending.forEach((b,i)=>{
      const div = document.createElement('div'); div.className = 'row';
      div.innerHTML = `<div>${i+1}. ${money(b.amount)}${b.auto? ' — auto x'+b.auto : ''}</div>
                       <div style="display:flex;gap:8px">
                         <button class="btn" data-i="${i}" data-action="edit">Edit</button>
                         <button class="btn" data-i="${i}" data-action="remove">Remove</button>
                       </div>`;
      parent.appendChild(div);
    });
  }
  function renderLocked(){
    const parent = $('locked'); parent.innerHTML = '';
    if(state.locked.length === 0){ parent.textContent = '(empty)'; return; }
    state.locked.forEach((b,i)=>{
      const cur = state.points[state.points.length-1]?.m || 1;
      const pot = b.amount * cur;
      const div = document.createElement('div'); div.className = 'row';
      div.innerHTML = `<div>#${i+1} ${money(b.amount)}${b.auto? ' — auto x'+b.auto : ''} — pot ${money(pot)}</div>
                       <div style="display:flex;gap:8px"><button class="btn" data-i="${i}" data-action="cash">Cashout</button></div>`;
      parent.appendChild(div);
    });
  }
  function renderHistory(){ /* history is populated by pushHistory; nothing to render here */ }
  function renderRecent(){
    const box = $('recent'); box.innerHTML = '';
    state.recent.forEach(x=>{
      const el = document.createElement('div'); el.className = 'pill';
      el.textContent = Number(x).toFixed(2);
      el.style.background = x >= 1.5 ? 'linear-gradient(90deg,var(--good),#baf6d3)' : 'linear-gradient(90deg,var(--bad),#ff9a9a)';
      box.appendChild(el);
    });
  }
  function renderOnboardPotential(){
    const onboard = state.pending.reduce((s,b)=>s+b.amount,0) + state.locked.reduce((s,b)=>s+b.amount,0);
    $('onboard').textContent = money(onboard);
    const potential = state.locked.reduce((s,b)=> s + b.amount * (state.points[state.points.length-1]?.m || 1), 0);
    $('potential').textContent = money(potential);
  }
  function renderAll(){
    renderQueue();
    renderLocked();
    renderOnboardPotential();
    renderHistory();
  }

  // queue editing handlers (event delegation)
  $('queue').addEventListener('click', (e)=>{
    const btn = e.target.closest('button');
    if(!btn) return;
    const i = Number(btn.dataset.i);
    const action = btn.dataset.action;
    if(action === 'remove'){ state.pending.splice(i,1); renderAll(); }
    if(action === 'edit'){
      const b = state.pending[i];
      const na = prompt('New amount', b.amount);
      if(na!==null){ const v = Number(na); if(!isNaN(v) && v>0) b.amount = v; }
      const at = prompt('Auto x (empty = off)', b.auto || '');
      if(at!==null){ const t = parseFloat(at); b.auto = isNaN(t)? null : t; }
      renderAll();
    }
  });

  // locked handlers (cash buttons)
  $('locked').addEventListener('click', (e)=>{
    const btn = e.target.closest('button');
    if(!btn) return;
    const i = Number(btn.dataset.i);
    const action = btn.dataset.action;
    if(action === 'cash') cashOne(i);
  });

  // Ribbon drawing helpers
  function mapX(i){
    const w = canvas.width / (devicePixelRatio || 1);
    const margin = 60;
    const max = Math.max(200, state.points.length);
    const frac = i / (max - 1 || 1);
    return margin + frac * (w - margin*2);
  }
  function mapY(m){
    const h = canvas.height / (devicePixelRatio || 1);
    const margin = 50;
    const cap = Math.max(100, state.target || 1000);
    const logMax = Math.log10(cap);
    const lm = Math.log10(Math.max(1, m));
    const frac = (lm - 0) / Math.max(1e-6, (logMax - 0));
    return h - margin - frac * (h - margin*2);
  }
  function drawRibbon(){
    const w = canvas.width / (devicePixelRatio || 1);
    const h = canvas.height / (devicePixelRatio || 1);
    ctx.clearRect(0,0,w,h);
    if(state.points.length < 2) return;
    const coords = state.points.map((p,i)=>({x:mapX(i), y:mapY(p.m)}));
    // shadow
    ctx.save();
    ctx.lineWidth = 20; ctx.lineCap = 'round';
    ctx.strokeStyle = 'rgba(0,0,0,0.18)';
    ctx.beginPath(); coords.forEach((p,i)=> i===0?ctx.moveTo(p.x,p.y):ctx.lineTo(p.x,p.y)); ctx.stroke();
    // band
    ctx.lineWidth = 12;
    const g = ctx.createLinearGradient(0,0,w,0); g.addColorStop(0,'#00d4ff'); g.addColorStop(1,'#7afcff');
    ctx.strokeStyle = g; ctx.beginPath(); coords.forEach((p,i)=> i===0?ctx.moveTo(p.x,p.y):ctx.lineTo(p.x,p.y)); ctx.stroke();
    // head dot
    const last = coords[coords.length-1];
    ctx.beginPath(); ctx.fillStyle = '#fff'; ctx.arc(last.x,last.y,6,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawGridLabels(){
    const w = canvas.width / (devicePixelRatio || 1);
    const h = canvas.height / (devicePixelRatio || 1);
    // labels are drawn on top-left corner area
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.font = '12px Inter, sans-serif';
    [1,2,3,5,10,20,50,100,200,500].forEach(v=>{
      const y = mapY(v);
      ctx.fillText('x'+v, 12, y + 4);
    });
    ctx.restore();
  }

  // main animation loop: single RAF
  function loop(now){
    if(!state.last) state.last = now;
    const dt = (now - state.last) / 1000;
    state.last = now;
    if(state.running){
      state.t += dt;
      const m = growth(state.t);
      state.points.push({t: state.t, m: Math.min(m, 6000)});
      if(state.points.length > 6000) state.points.shift();
      $('bigX').textContent = 'x' + state.points[state.points.length-1].m.toFixed(2);
      // auto-cash
      const cur = state.points[state.points.length-1].m;
      for(let i = state.locked.length -1; i >= 0; i--){
        const b = state.locked[i];
        if(b.auto && !isNaN(b.auto) && cur >= b.auto){
          const payout = b.amount * cur;
          setBalance(balance + payout);
          pushHistory(`Auto ${money(b.amount)} @ x${cur.toFixed(2)} -> ${money(payout)}`, payout - b.amount, 'Aviator');
          state.locked.splice(i,1);
          sCash();
        }
      }
      // check crash
      if(state.points[state.points.length-1].m >= state.target){
        endRound(state.target);
      }
    }
    // render visuals
    drawRibbon();
    drawGridLabels();
    renderOnboardPotential();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Event bindings for buttons
  $('addQueue').addEventListener('click', ()=>{
    const amt = Number($('betAmt').value) || 0;
    const auto = parseFloat($('autoX').value);
    if(amt <= 0){ alert('Enter valid amount'); return; }
    if(amt > balance){ alert('Insufficient balance'); return; }
    state.pending.push({amount: amt, auto: isNaN(auto) ? null : auto});
    renderAll();
    toast('Added to queue');
  });

  $('placeNow').addEventListener('click', ()=>{
    const total = state.pending.reduce((s,b)=>s+b.amount,0);
    if(total <= 0){ alert('No queued bets'); return; }
    if(total > balance){ alert('Insufficient balance to place'); return; }
    setBalance(balance - total);
    state.locked = state.locked.concat(state.pending.map(b=>Object.assign({},b)));
    state.pending = [];
    pushHistory(`Placed ${money(total)}`, -total, 'Aviator');
    renderAll();
    toast('Placed bets');
  });

  $('startNow').addEventListener('click', ()=>{ if(state.running) { alert('Round already running'); return; } beginRound(); });

  $('cashAll').addEventListener('click', ()=>{ cashAll(); });

  $('addFunds').addEventListener('click', ()=>{ setBalance(balance + 1000); pushHistory('Added +₴1000', 1000, 'System'); toast('Added ₴1000'); });

  // initial UI
  renderAll();
  renderRecent();
  startCountdown(10);
  resizeCanvas();

}); // DOMContentLoaded
</script>
</body>
</html>
